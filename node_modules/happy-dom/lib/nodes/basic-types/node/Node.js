"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var NodeType_1 = __importDefault(require("./NodeType"));
var ClassList_1 = __importDefault(require("../element/ClassList"));
var EventTarget_1 = __importDefault(require("../../../event/EventTarget"));
var MutationRecord_1 = __importDefault(require("../../../mutation-observer/MutationRecord"));
var MutationType_1 = __importDefault(require("../../../mutation-observer/MutationType"));
var CLONE_REFERENCE_PROPERTIES = [
    'ownerDocument',
    'tagName',
    'nodeType',
    '_textContent',
    'mode',
    'name',
    'type',
    'disabled',
    'autofocus',
    'required',
    '_value'
];
var CLONE_OBJECT_ASSIGN_PROPERTIES = ['_attributesMap', 'style'];
var CLONE_NODE_PROPERTIES = ['documentElement', 'body', 'head'];
/**
 * Node
 */
var Node = /** @class */ (function (_super) {
    __extends(Node, _super);
    /**
     * Constructor.
     */
    function Node() {
        var _this = _super.call(this) || this;
        _this.ownerDocument = null;
        _this.parentNode = null;
        _this.childNodes = [];
        // Protected properties
        _this._isConnected = false;
        // Custom Properties (not part of HTML standard)
        _this._observers = [];
        _this.ownerDocument = _this.constructor.ownerDocument;
        return _this;
    }
    Object.defineProperty(Node.prototype, "isConnected", {
        /**
         * "true" if connected to DOM.
         *
         * @return {boolean} "true" if connected.
         */
        get: function () {
            return this._isConnected;
        },
        /**
         * Sets the connected state.
         *
         * @param {boolean} isConnected "true" if connected.
         */
        set: function (isConnected) {
            if (this._isConnected !== isConnected) {
                this._isConnected = isConnected;
                for (var _i = 0, _a = this.childNodes; _i < _a.length; _i++) {
                    var child = _a[_i];
                    child.isConnected = isConnected;
                }
                // eslint-disable-next-line
                if (this.shadowRoot) {
                    // eslint-disable-next-line
                    this.shadowRoot.isConnected = isConnected;
                }
                if (isConnected && this.connectedCallback) {
                    this.connectedCallback();
                }
                else if (!isConnected && this.disconnectedCallback) {
                    this.disconnectedCallback();
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "nodeValue", {
        /**
         * Node value.
         *
         * @return {string} Node value.
         */
        get: function () {
            return null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "nodeName", {
        /**
         * Node name.
         *
         * @return {string} Node name.
         */
        get: function () {
            return '';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "previousSibling", {
        /**
         * Previous sibling.
         *
         * @return {Node} Node.
         */
        get: function () {
            if (this.parentNode) {
                var index = this.parentNode.childNodes.indexOf(this);
                if (index > 0) {
                    return this.parentNode.childNodes[index - 1];
                }
            }
            return null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "nextSibling", {
        /**
         * Next sibling.
         *
         * @return {Node} Node.
         */
        get: function () {
            if (this.parentNode) {
                var index = this.parentNode.childNodes.indexOf(this);
                if (index > -1 && index + 1 < this.parentNode.childNodes.length) {
                    return this.parentNode.childNodes[index + 1];
                }
            }
            return null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "previousElementSibling", {
        /**
         * Previous element sibling.
         *
         * @return {Node} Node.
         */
        get: function () {
            var sibling = this.previousSibling;
            while (sibling && sibling.nodeType !== NodeType_1.default.ELEMENT_NODE) {
                sibling = sibling.previousSibling;
            }
            return sibling;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "nextElementSibling", {
        /**
         * Next element sibling.
         *
         * @return {Node} Node.
         */
        get: function () {
            var sibling = this.nextSibling;
            while (sibling && sibling.nodeType !== NodeType_1.default.ELEMENT_NODE) {
                sibling = sibling.nextSibling;
            }
            return sibling;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "firstChild", {
        /**
         * First child.
         *
         * @return {Node} Node.
         */
        get: function () {
            if (this.childNodes.length > 0) {
                return this.childNodes[0];
            }
            return null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "lastChild", {
        /**
         * Last child.
         *
         * @return {Node} Node.
         */
        get: function () {
            if (this.childNodes.length > 0) {
                return this.childNodes[this.childNodes.length - 1];
            }
            return null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "firstElementChild", {
        /**
         * First element child.
         *
         * @return {Node} Node.
         */
        get: function () {
            for (var _i = 0, _a = this.childNodes; _i < _a.length; _i++) {
                var node = _a[_i];
                if (node.nodeType === NodeType_1.default.ELEMENT_NODE) {
                    return node;
                }
            }
            return null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Node.prototype, "lastElementChild", {
        /**
         * Last element child.
         *
         * @return {Node} Node.
         */
        get: function () {
            for (var i = this.childNodes.length - 1; i >= 0; i--) {
                if (this.childNodes[i].nodeType === NodeType_1.default.ELEMENT_NODE) {
                    return this.childNodes[i];
                }
            }
            return null;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns "true" if the node has attributes.
     *
     * @return {boolean} "true" if the node has attributes.
     */
    Node.prototype.hasAttributes = function () {
        return false;
    };
    /**
     * Clones a node.
     *
     * @param {boolean} [deep=true] "false" to not clone deep.
     * @return {Node} Cloned node.
     */
    Node.prototype.cloneNode = function (deep) {
        if (deep === void 0) { deep = true; }
        var clone = new this.constructor();
        for (var _i = 0, _a = Object.keys(this); _i < _a.length; _i++) {
            var key = _a[_i];
            if (key !== '_isConnected' && key !== '_observers') {
                if (key === 'childNodes') {
                    if (deep) {
                        for (var _b = 0, _c = this[key]; _b < _c.length; _b++) {
                            var childNode = _c[_b];
                            var childClone = childNode.cloneNode();
                            childClone.parentNode = clone;
                            clone.childNodes.push(childClone);
                        }
                    }
                }
                else if (key === 'classList') {
                    // eslint-disable-next-line
                    clone[key] = new ClassList_1.default(clone);
                }
                else if (CLONE_NODE_PROPERTIES.includes(key)) {
                    if (deep) {
                        clone[key] = this[key].cloneNode();
                        clone[key].parentNode = clone;
                    }
                }
                else if (CLONE_OBJECT_ASSIGN_PROPERTIES.includes(key)) {
                    clone[key] = Object.assign({}, this[key]);
                }
                else if (CLONE_REFERENCE_PROPERTIES.includes(key)) {
                    clone[key] = this[key];
                }
            }
        }
        return clone;
    };
    /**
     * Inserts nodes before the first child of node, while replacing strings in nodes with equivalent Text nodes.
     */
    Node.prototype.prepend = function () {
        var _this = this;
        var nodes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            nodes[_i] = arguments[_i];
        }
        var originalFirstChild = this.firstChild;
        nodes.forEach(function (item) {
            return _this.insertBefore(typeof item === 'string' ? _this.ownerDocument.createTextNode(item) : item, originalFirstChild);
        });
    };
    /**
     * Inserts nodes after the last child of node, while replacing strings in nodes with equivalent Text nodes.
     */
    Node.prototype.append = function () {
        var _this = this;
        var nodes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            nodes[_i] = arguments[_i];
        }
        nodes.forEach(function (item) { return _this.appendChild(typeof item === 'string' ? _this.ownerDocument.createTextNode(item) : item); });
    };
    /**
     * Append a child node to childNodes.
     *
     * @param  {Node} node Node to append.
     * @return {Node} Appended node.
     */
    Node.prototype.appendChild = function (node) {
        if (node === this) {
            throw new Error('Not possible to append self as child self.');
        }
        if (node.nodeType === NodeType_1.default.DOCUMENT_FRAGMENT_NODE) {
            for (var _i = 0, _a = node.childNodes.slice(); _i < _a.length; _i++) {
                var child = _a[_i];
                this.appendChild(child);
            }
            return node;
        }
        if (node.parentNode) {
            var index = node.parentNode.childNodes.indexOf(node);
            if (index !== -1) {
                node.parentNode.childNodes.splice(index, 1);
            }
        }
        this.childNodes.push(node);
        node.parentNode = this;
        node.isConnected = this.isConnected;
        // MutationObserver
        if (this._observers.length > 0) {
            var record = new MutationRecord_1.default();
            record.type = MutationType_1.default.childList;
            record.addedNodes = [node];
            for (var _b = 0, _c = this._observers; _b < _c.length; _b++) {
                var observer = _c[_b];
                if (observer.options.subtree) {
                    node._observe(observer);
                }
                if (observer.options.childList) {
                    observer.callback([record]);
                }
            }
        }
        return node;
    };
    /**
     * Removes the node from its parent.
     */
    Node.prototype.remove = function () {
        if (this.parentNode) {
            this.parentNode.removeChild(this);
        }
    };
    /**
     * Remove Child element from childNodes array.
     *
     * @param {Node} node Node to remove
     */
    Node.prototype.removeChild = function (node) {
        var index = this.childNodes.indexOf(node);
        if (index === -1) {
            throw new Error('Failed to remove node. Node is not child of parent.');
        }
        this.childNodes.splice(index, 1);
        node.parentNode = null;
        node.isConnected = false;
        // MutationObserver
        if (this._observers.length > 0) {
            var record = new MutationRecord_1.default();
            record.type = MutationType_1.default.childList;
            record.removedNodes = [node];
            for (var _i = 0, _a = this._observers; _i < _a.length; _i++) {
                var observer = _a[_i];
                node._unobserve(observer);
                if (observer.options.childList) {
                    observer.callback([record]);
                }
            }
        }
    };
    /**
     * Inserts a node before another.
     *
     * @param {Node} newNode Node to insert.
     * @param {Node} referenceNode Node to insert before.
     * @return {Node} Inserted node.
     */
    Node.prototype.insertBefore = function (newNode, referenceNode) {
        if (newNode.nodeType === NodeType_1.default.DOCUMENT_FRAGMENT_NODE) {
            for (var _i = 0, _a = newNode.childNodes.slice(); _i < _a.length; _i++) {
                var child = _a[_i];
                this.insertBefore(child, referenceNode);
            }
            return newNode;
        }
        if (referenceNode === null) {
            return this.appendChild(newNode);
        }
        var index = this.childNodes.indexOf(referenceNode);
        if (index === -1) {
            throw new Error('Failed to insert node. Reference node is not child of parent.');
        }
        if (newNode.parentNode) {
            var index_1 = newNode.parentNode.childNodes.indexOf(newNode);
            if (index_1 !== -1) {
                newNode.parentNode.childNodes.splice(index_1, 1);
            }
        }
        this.childNodes.splice(index, 0, newNode);
        newNode.parentNode = this;
        newNode.isConnected = this.isConnected;
        // MutationObserver
        if (this._observers.length > 0) {
            var record = new MutationRecord_1.default();
            record.type = MutationType_1.default.childList;
            record.addedNodes = [newNode];
            for (var _b = 0, _c = this._observers; _b < _c.length; _b++) {
                var observer = _c[_b];
                if (observer.options.subtree) {
                    newNode._observe(observer);
                }
                if (observer.options.childList) {
                    observer.callback([record]);
                }
            }
        }
        return newNode;
    };
    /**
     * Replaces a node with another.
     *
     * @param {Node} newChild New child.
     * @param {Node} oldChild Old child.
     * @return {Node} Replaced node.
     */
    Node.prototype.replaceChild = function (newChild, oldChild) {
        this.insertBefore(newChild, oldChild);
        this.removeChild(oldChild);
        return oldChild;
    };
    /**
     * Dispatches an event.
     *
     * @override
     * @param {Event} event Event.
     * @return {boolean} The return value is false if event is cancelable and at least one of the event handlers which handled this event called Event.preventDefault()
     */
    Node.prototype.dispatchEvent = function (event) {
        var onEventName = 'on' + event.type.toLowerCase();
        if (typeof this[onEventName] === 'function') {
            this[onEventName].call(this, event);
        }
        var returnValue = _super.prototype.dispatchEvent.call(this, event);
        if (event.bubbles &&
            this.parentNode !== null &&
            !event._propagationStopped &&
            !this.parentNode.dispatchEvent(event)) {
            returnValue = false;
        }
        return returnValue;
    };
    /**
     * Observeres the node.
     * Used by MutationObserver, but it is not part of the HTML standard.
     *
     * @param {MutationObserverListener} listener Listener.
     */
    Node.prototype._observe = function (listener) {
        this._observers.push(listener);
        if (listener.options.subtree) {
            for (var _i = 0, _a = this.childNodes; _i < _a.length; _i++) {
                var node = _a[_i];
                node._observe(listener);
            }
        }
    };
    /**
     * Stops observing the node.
     * Used by MutationObserver, but it is not part of the HTML standard.
     *
     * @param {MutationObserverListener} listener Listener.
     */
    Node.prototype._unobserve = function (listener) {
        var index = this._observers.indexOf(listener);
        if (index !== -1) {
            this._observers.splice(index, 1);
        }
        if (listener.options.subtree) {
            for (var _i = 0, _a = this.childNodes; _i < _a.length; _i++) {
                var node = _a[_i];
                node._unobserve(listener);
            }
        }
    };
    // Public properties
    Node.ownerDocument = null;
    return Node;
}(EventTarget_1.default));
exports.default = Node;
// Adds Note types to the Node class (part of the HTML standard)
for (var _i = 0, _a = Object.keys(NodeType_1.default); _i < _a.length; _i++) {
    var key = _a[_i];
    Node[key] = NodeType_1.default[key];
}
//# sourceMappingURL=Node.js.map