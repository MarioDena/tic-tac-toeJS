"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var SelfClosingElements_json_1 = __importDefault(require("../html-config/SelfClosingElements.json"));
var SelfClosingSVGElements_json_1 = __importDefault(require("../html-config/SelfClosingSVGElements.json"));
/**
 * HTML parser.
 */
var HTMLParser = /** @class */ (function () {
    function HTMLParser() {
    }
    /**
     * Parses HTML and returns a root element.
     *
     * @param  {Document} document Document.
     * @param  {string} data HTML data.
     * @return {Element} Root element.
     */
    HTMLParser.parse = function (document, data) {
        var root = document.createElement('root');
        var stack = [root];
        var markupRegexp = /<(\/?)([a-z][-.0-9_a-z]*)\s*([^>]*?)(\/?)>/gi;
        var currentParent = root;
        var lastTextIndex = 0;
        var match;
        while ((match = markupRegexp.exec(data))) {
            var tagName = match[2].toLowerCase();
            var isStartTag = !match[1];
            if (currentParent && match.index !== lastTextIndex) {
                var text = data.substring(lastTextIndex, match.index);
                this.appendTextAndCommentNodes(document, currentParent, text);
            }
            if (isStartTag) {
                var newElement = document.createElement(tagName);
                newElement._setRawAttributes(match[3]);
                if (!SelfClosingElements_json_1.default.includes(tagName) && !SelfClosingSVGElements_json_1.default.includes(tagName)) {
                    currentParent = currentParent.appendChild(newElement);
                    stack.push(currentParent);
                }
                else {
                    currentParent.appendChild(newElement);
                }
                lastTextIndex = markupRegexp.lastIndex;
            }
            else {
                stack.pop();
                currentParent = stack[stack.length - 1];
                lastTextIndex = markupRegexp.lastIndex;
            }
        }
        // Text after last element
        if ((!match && data.length > 0) || (match && lastTextIndex !== match.index)) {
            var text = data.substring(lastTextIndex);
            this.appendTextAndCommentNodes(document, root, text);
        }
        return root;
    };
    /**
     * Appends text and comment nodes.
     *
     * @param  {Document} document Document.
     * @param  {Node} node Node.
     * @param  {string} text Text to search in.
     */
    HTMLParser.appendTextAndCommentNodes = function (document, node, text) {
        for (var _i = 0, _a = this.getTextAndCommentNodes(document, text); _i < _a.length; _i++) {
            var innerNode = _a[_i];
            node.appendChild(innerNode);
        }
    };
    /**
     * Returns text and comment nodes from a text.
     *
     * @param  {Document} document Document.
     * @param  {string} text Text to search in.
     * @return {Node[]} Nodes.
     */
    HTMLParser.getTextAndCommentNodes = function (document, text) {
        var nodes = [];
        var commentRegexp = /<!--(.*?)-->/gms;
        var lastIndex = 0;
        var match;
        while ((match = commentRegexp.exec(text))) {
            if (match.index > 0) {
                var textNode = document.createTextNode(text.substring(lastIndex, match.index));
                nodes.push(textNode);
            }
            var commentNode = document.createComment(match[1]);
            nodes.push(commentNode);
            lastIndex = match.index + match[0].length;
        }
        if (lastIndex < text.length) {
            var textNode = document.createTextNode(text.substring(lastIndex));
            nodes.push(textNode);
        }
        return nodes;
    };
    return HTMLParser;
}());
exports.default = HTMLParser;
//# sourceMappingURL=HTMLParser.js.map