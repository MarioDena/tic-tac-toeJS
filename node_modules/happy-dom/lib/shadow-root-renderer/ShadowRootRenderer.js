"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var Element_1 = __importDefault(require("../nodes/basic-types/element/Element"));
var ShadowRoot_1 = __importDefault(require("../nodes/basic-types/shadow-root/ShadowRoot"));
var ScopeCSS_1 = __importDefault(require("./css/ScopeCSS"));
/**
 * Patch for scoping elements when requesting "document.documentElement.innerHTML" or "document.documentElement.outerHTML".
 * This patch is mainly useful on server side DOMs.
 */
var ShadowRootRenderer = /** @class */ (function () {
    function ShadowRootRenderer() {
    }
    /**
     * Renders an element scoped without touching the original elements.
     *
     * @param {Element|DocumentFragment} element Element to render.
     * @param {ScopedCSSCache} cssCache Options object.
     * @return {string} Result.
     */
    ShadowRootRenderer.getInnerHTML = function (element, cssCache) {
        var clone = element.cloneNode(true);
        this.scopeElement(clone, cssCache);
        return clone.shadowRoot.innerHTML;
    };
    /**
     * Scopes an element.
     *
     * @param {Element} element Element to render.
     * @param {ScopedCSSCache} cssCache Options object.
     */
    ShadowRootRenderer.scopeElement = function (element, cssCache) {
        this.extractAndScopeCSS(element, cssCache);
        this.moveChildNodesIntoSlots(element);
    };
    /**
     * Moves child nodes into shadow root slot elements.
     *
     * @param {Element} element Element.
     */
    ShadowRootRenderer.moveChildNodesIntoSlots = function (element) {
        var slotChildren = {};
        var slots = Array.from(element.shadowRoot.querySelectorAll('slot'));
        for (var i = 0, max = element.children.length; i < max; i++) {
            var child = element.children[i];
            var name = child.getAttribute('slot') || 'default';
            slotChildren[name] = slotChildren[name] || [];
            slotChildren[name].push(child);
        }
        for (var _i = 0, slots_1 = slots; _i < slots_1.length; _i++) {
            var slot = slots_1[_i];
            var name = slot.getAttribute('name') || 'default';
            if (slotChildren[name]) {
                for (var _a = 0, _b = slotChildren[name]; _a < _b.length; _a++) {
                    var child = _b[_a];
                    slot.parentNode.insertBefore(child, slot);
                }
                slot.parentNode.removeChild(slot);
            }
        }
        if (element.childNodes.length > 0) {
            // eslint-disable-next-line
            console.warn('Warning! Custom element "' + element.tagName + '" did not have any matching slot for ' + element.childNodes.length + ' child node(s).');
            for (var _c = 0, _d = Array.from(element.childNodes); _c < _d.length; _c++) {
                var child = _d[_c];
                element.removeChild(child);
            }
        }
    };
    /**
     * Extracts CSS.
     *
     * @param {Element} element Element.
     * @param {ElementRenderOptions} cssCache Options object.
     */
    ShadowRootRenderer.extractAndScopeCSS = function (element, cssCache) {
        var css = this.extractCSS(element.shadowRoot);
        var scopeID = cssCache.getScopeID(css);
        var scopedCSS = cssCache.getScoped(css);
        if (!scopedCSS) {
            scopedCSS = ScopeCSS_1.default.scope(css, scopeID, element.tagName);
            cssCache.setScoped(css, scopedCSS);
        }
        element.classList.add(scopeID);
        this.scopeShadowRoot(element.shadowRoot, scopeID);
    };
    /**
     * Extracts CSS.
     *
     * @param {ShadowRoot} shadowRoot Shadow root.
     * @return {string} CSS.
     */
    ShadowRootRenderer.extractCSS = function (shadowRoot) {
        var styles = Array.from(shadowRoot.querySelectorAll('style'));
        var css = '';
        for (var _i = 0, styles_1 = styles; _i < styles_1.length; _i++) {
            var style = styles_1[_i];
            style.parentNode.removeChild(style);
            css += style.textContent;
        }
        return css;
    };
    /**
     * Scopes an element by adding a unique id as a class to it and its children.
     *
     * @param {Element|ShadowRoot} element Element to scope.
     * @param {string} id Unique ID.
     */
    ShadowRootRenderer.scopeShadowRoot = function (element, id) {
        if (element instanceof Element_1.default) {
            element.classList.add(id);
        }
        if (element instanceof ShadowRoot_1.default || (element instanceof Element_1.default && element.tagName !== 'slot')) {
            for (var i = 0, max = element.children.length; i < max; i++) {
                var child = element.children[i];
                this.scopeShadowRoot(child, id);
            }
        }
    };
    return ShadowRootRenderer;
}());
exports.default = ShadowRootRenderer;
//# sourceMappingURL=ShadowRootRenderer.js.map