"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var Element_1 = __importDefault(require("../../nodes/basic/element/Element"));
var ShadowRootScoper_1 = __importDefault(require("./ShadowRootScoper"));
var HTMLRenderResult_1 = __importDefault(require("../HTMLRenderResult"));
var SELF_CLOSED_REGEXP = /^(img|br|hr|area|base|input|doctype|link)$/i;
var META_REGEXP = /^meta$/i;
/**
 * Utility for converting an element to string.
 *
 * @class QuerySelector
 */
var ShadowRootRenderer = /** @class */ (function () {
    /**
     * Renders an element as HTML.
     *
     * @param {IShadowRootRenderOptions} [renderOptions] Render this.renderOptions.
     */
    function ShadowRootRenderer(renderOptions) {
        if (renderOptions === void 0) { renderOptions = {}; }
        this.renderOptions = renderOptions;
        this.shadowRootScoper = new ShadowRootScoper_1.default(renderOptions);
    }
    /**
     * Renders an element as HTML.
     *
     * @param {Element} element Element to render.
     * @return {HTMLRenderResult} Result.
     */
    ShadowRootRenderer.prototype.getOuterHTML = function (element) {
        var tagName = element.tagName.toLowerCase();
        var isUnClosed = META_REGEXP.test(tagName);
        var isSelfClosed = SELF_CLOSED_REGEXP.test(tagName);
        var result = new HTMLRenderResult_1.default();
        if (isUnClosed) {
            result.html = "<" + tagName + this.getAttributes(element) + ">";
        }
        else if (isSelfClosed) {
            result.html = "<" + tagName + this.getAttributes(element) + "/>";
        }
        else {
            var innerElement = element;
            var outerElement = element;
            if (this.renderOptions.openShadowRoots && element instanceof Element_1.default && element.shadowRoot) {
                outerElement = this.shadowRootScoper.getScopedClone(element);
                innerElement = outerElement.shadowRoot;
            }
            var innerHTML = this.getInnerHTML(innerElement).html;
            result.html = "<" + tagName + this.getAttributes(outerElement) + ">" + innerHTML + "</" + tagName + ">";
        }
        if (this.renderOptions.openShadowRoots) {
            result.css = this.shadowRootScoper.getScopedCSS();
        }
        return result;
    };
    /**
     * Renders an element as HTML.
     *
     * @param {Element|DocumentFragment|ShadowRoot} element Element to render.
     * @return {HTMLRenderResult} Result.
     */
    ShadowRootRenderer.prototype.getInnerHTML = function (element) {
        var result = new HTMLRenderResult_1.default();
        var renderElement = element.content || element;
        for (var _i = 0, _a = renderElement.childNodes.slice(); _i < _a.length; _i++) {
            var child = _a[_i];
            if (child instanceof Element_1.default) {
                result.html += this.getOuterHTML(child).html;
            }
            else {
                result.html += child.toString();
            }
        }
        if (this.renderOptions.openShadowRoots) {
            result.css = this.shadowRootScoper.getScopedCSS();
        }
        return result;
    };
    /**
     * Returns attributes as a string.
     *
     * @param {Element} element Element.
     * @return {string} Attributes.
     */
    ShadowRootRenderer.prototype.getAttributes = function (element) {
        var rawAttributes = element._getRawAttributes();
        return rawAttributes ? ' ' + rawAttributes : '';
    };
    return ShadowRootRenderer;
}());
exports.default = ShadowRootRenderer;
//# sourceMappingURL=ShadowRootRenderer.js.map