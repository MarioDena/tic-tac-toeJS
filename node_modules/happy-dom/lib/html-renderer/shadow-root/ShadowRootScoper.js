"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var ScopedCSSCache_1 = __importDefault(require("./css/ScopedCSSCache"));
var Element_1 = __importDefault(require("../../nodes/basic/element/Element"));
var ShadowRoot_1 = __importDefault(require("../../nodes/basic/shadow-root/ShadowRoot"));
var StyleScoper_1 = __importDefault(require("./css/StyleScoper"));
/**
 * Scopes elements and CSS inside shadow roots.
 */
var ShadowRootScoper = /** @class */ (function () {
    /**
     * Renders an element as HTML.
     *
     * @param {IShadowRootRenderOptions} renderOptions Render this.renderOptions.
     */
    function ShadowRootScoper(renderOptions) {
        this.scopedCSSCache = new ScopedCSSCache_1.default();
        this.renderOptions = renderOptions;
    }
    /**
     * Clones an element and scopes it.
     *
     * @param {Element} element Element to render.
     * @param {ScopedCSSCache} cssCache Options object.
     * @param {IShadowRootRenderOptions} options Render options.
     * @returns {Element} Element clone.
     */
    ShadowRootScoper.prototype.getScopedClone = function (element) {
        var clone = element.cloneNode(true);
        this.extractAndScopeCSS(clone);
        this.moveChildNodesIntoSlots(clone);
        return clone;
    };
    /**
     * Returns scoped CSS.
     *
     * @returns {string[]} CSS strings.
     */
    ShadowRootScoper.prototype.getScopedCSS = function () {
        return this.scopedCSSCache.getAllScoped();
    };
    /**
     * Moves child nodes into shadow root slot elements.
     *
     * @param {Element} element Element.
     */
    ShadowRootScoper.prototype.moveChildNodesIntoSlots = function (element) {
        var slotChildren = {};
        var slots = Array.from(element.shadowRoot.querySelectorAll('slot'));
        for (var i = 0, max = element.children.length; i < max; i++) {
            var child = element.children[i];
            var name = child.getAttribute('slot') || 'default';
            slotChildren[name] = slotChildren[name] || [];
            slotChildren[name].push(child);
        }
        for (var _i = 0, slots_1 = slots; _i < slots_1.length; _i++) {
            var slot = slots_1[_i];
            var name = slot.getAttribute('name') || 'default';
            if (slotChildren[name]) {
                for (var _a = 0, _b = slotChildren[name]; _a < _b.length; _a++) {
                    var child = _b[_a];
                    slot.parentNode.insertBefore(child, slot);
                }
                slot.parentNode.removeChild(slot);
            }
        }
        if (element.childNodes.length > 0) {
            // eslint-disable-next-line
            console.warn('Warning! Custom element "' + element.tagName + '" did not have any matching slot for ' + element.childNodes.length + ' child node(s).');
            for (var _c = 0, _d = Array.from(element.childNodes); _c < _d.length; _c++) {
                var child = _d[_c];
                element.removeChild(child);
            }
        }
    };
    /**
     * Extracts CSS.
     *
     * @param {Element} element Element.
     */
    ShadowRootScoper.prototype.extractAndScopeCSS = function (element) {
        var options = this.renderOptions;
        var cache = this.scopedCSSCache;
        if (options.extractCSS && options.scopeCSS) {
            var css = this.extractCSS(element.shadowRoot);
            var scopeID = cache.getScopeID(css);
            var scopedCSS = cache.getScoped(css);
            if (!scopedCSS) {
                scopedCSS = StyleScoper_1.default.scope(css, scopeID, element.tagName);
                cache.setScoped(css, scopedCSS);
            }
            element.classList.add(scopeID);
            this.scopeChildElements(element.shadowRoot, scopeID);
        }
        else if (options.extractCSS) {
            var css = this.extractCSS(element.shadowRoot);
            cache.setScoped(css, css);
        }
        else if (options.scopeCSS) {
            var styles = Array.from(element.shadowRoot.querySelectorAll('style'));
            for (var _i = 0, styles_1 = styles; _i < styles_1.length; _i++) {
                var style = styles_1[_i];
                var css = style.textContent;
                var scopeID = cache.getScopeID(css);
                element.classList.add(scopeID);
                style.textContent = StyleScoper_1.default.scope(css, scopeID, element.tagName);
                cache.setScoped(css, style.textContent);
                this.scopeChildElements(element.shadowRoot, scopeID);
            }
        }
    };
    /**
     * Extracts CSS.
     *
     * @param {ShadowRoot} shadowRoot Shadow root.
     * @return {string} CSS.
     */
    ShadowRootScoper.prototype.extractCSS = function (shadowRoot) {
        var styles = Array.from(shadowRoot.querySelectorAll('style'));
        var css = '';
        for (var _i = 0, styles_2 = styles; _i < styles_2.length; _i++) {
            var style = styles_2[_i];
            style.parentNode.removeChild(style);
            css += style.textContent;
        }
        return css;
    };
    /**
     * Scopes an element by adding a unique id as a class to it and its children.
     *
     * @param {Element|ShadowRoot} element Element to scope.
     * @param {string} id Unique ID.
     */
    ShadowRootScoper.prototype.scopeChildElements = function (element, id) {
        if (element instanceof Element_1.default) {
            element.classList.add(id);
        }
        if (element instanceof ShadowRoot_1.default || (element instanceof Element_1.default && element.tagName !== 'slot')) {
            for (var i = 0, max = element.children.length; i < max; i++) {
                var child = element.children[i];
                this.scopeChildElements(child, id);
            }
        }
    };
    return ShadowRootScoper;
}());
exports.default = ShadowRootScoper;
//# sourceMappingURL=ShadowRootScoper.js.map